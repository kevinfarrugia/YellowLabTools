var debug = require('debug')('ylt:policies');
var offendersHelpers = require('../offendersHelpers');

var policies = {
    "DOMelementsCount": {
        "tool": "phantomas",
        "label": "DOM elements count",
        "message": "<p>A high number of DOM elements means a lot of work for the browser to render the page.</p><p>It also slows down JavaScript DOM queries, as there are more elements to search through.</p>",
        "isOkThreshold": 1500,
        "isBadThreshold": 3000,
        "isAbnormalThreshold": 4500,
        "hasOffenders": false
    },
    "DOMelementMaxDepth": {
        "tool": "phantomas",
        "label": "DOM max depth",
        "message": "<p>A deep DOM makes the CSS matching with DOM elements difficult.</p><p>It also slows down JavaScript modifications to the DOM because changing the dimensions of an element makes the browser re-calculate the dimensions of it's parents. Same thing for JavaScript events, that bubble up to the document root.</p>",
        "isOkThreshold": 15,
        "isBadThreshold": 25,
        "isAbnormalThreshold": 32,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var domArrays = offenders.map(offendersHelpers.domPathToArray);

            return {
                count: offenders.length,
                tree: offendersHelpers.listOfDomArraysToTree(domArrays)
            };
        }
    },
    "iframesCount": {
        "tool": "phantomas",
        "label": "Number of iframes",
        "message": "<p>iFrames are the most complex HTML elements. They are pages, just like the main page, and the browser needs to create a new page context, which has a cost.</p>",
        "isOkThreshold": 4,
        "isBadThreshold": 15,
        "isAbnormalThreshold": 30,
        "hasOffenders": true
    },
    "DOMidDuplicated": {
        "tool": "phantomas",
        "label": "IDs duplicated",
        "message": "<p>IDs of HTML elements must be document-wide unique. This can cause problems with getElementById returning the wrong element.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 10,
        "isAbnormalThreshold": 50,
        "hasOffenders": true
    },
    "scriptDuration": {
        "tool": "phantomas",
        "label": "Total JS execution time",
        "message": "<p>This is the number of milliseconds spent by the browser on JavaScript execution during page load.</p><p>For more details, try using the performance tab in Chrome DevTools. It is a bit complicated at first sight, but you'll be able to analyze exactly where this execution time is spent.</p>",
        "isOkThreshold": 500,
        "isBadThreshold": 2000,
        "isAbnormalThreshold": 4000,
        "hasOffenders": false,
        "unit": "ms"
    },
    "DOMaccesses": {
        "tool": "domAccessAgregator",
        "label": "DOM access",
        "message": "<p>This metric estimates the number of times the JavaScript reads, changes or binds the DOM.</p><p>The more your JavaScript code accesses the DOM, the slower the page will load.</p><p>Try, as much as possible, to have an HTML page fully generated by the server instead of making changes with JS.</p><p>Try to reduce the number of queries by refactoring your JavaScript code.</p><p>Binding too many events also has a cost.</p>",
        "isOkThreshold": 500,
        "isBadThreshold": 2500,
        "isAbnormalThreshold": 5000,
        "hasOffenders": true
    },
    "eventsScrollBound": {
        "tool": "phantomas",
        "label": "Scroll events bound",
        "message": "<p>Number of 'scroll' event listeners binded to 'window' or 'document'.</p><p>Asking too much work to the browser on scroll hurts the smoothness of the scroll. Merging all your event listeners into an unique listener can help you factorize their code and reduce their footprint on scroll.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 8,
        "isAbnormalThreshold": 15,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^bound by (.*) on ([^ ]+)$/.exec(offender);

                    if (!parts) {
                        debug('eventsScrollBound offenders transform function error with "%s"', offender);
                        return {
                            parseError: offender
                        };
                    }

                    var backtraceArray = offendersHelpers.backtraceToArray(parts[1]);
                    
                    return {
                        backtrace: backtraceArray || [],
                        target: parts[2]
                    };
                })
            };
        }
    },
    "jsErrors": {
        "tool": "phantomas",
        "label": "JavaScript errors",
        "message": "<p>Just to let you know there are some errors on the page.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 5,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^(.*) - (.*)$/.exec(offender);

                    if (!parts) {
                        debug('jsErrors offenders transform function error with "%s"', offender);
                        return {
                            parseError: offender
                        };
                    }

                    var backtraceArray = offendersHelpers.backtraceToArray(parts[2]);

                    return {
                        error: parts[1],
                        backtrace: backtraceArray || []
                    };
                })
            };
        }
    },
    "documentWriteCalls": {
        "tool": "phantomas",
        "label": "document.write calls",
        "message": "<p>They slow down the page construction, especially if they are used to insert scripts in the page. Remove them ASAP.</p><p>If you cannot remove them because they come from a third-party script (such as ads), have a look at <a href=\"https://github.com/krux/postscribe\" target=\"_blank\">PostScribe</a>.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 2,
        "isAbnormalThreshold": 6,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^document.write(ln)?\(\) used from (.*)$/.exec(offender);

                    if (parts) {

                        var writeFn = 'document.write' + (parts[1] || '');

                        var methodParts = /^([^\s]+) \((.+):(\d+)\)$/.exec(parts[2]);
                        if (methodParts) {
                            return {
                                writeFn: writeFn,
                                from: {
                                    functionName: methodParts[1],
                                    file: methodParts[2],
                                    line: methodParts[3]
                                }
                            };
                        } else {
                            var noMethodParts = /^(.+):(\d+)$/.exec(parts[2]);

                            if (noMethodParts) {
                                return {
                                    writeFn: writeFn,
                                    from: {
                                        file: noMethodParts[1],
                                        line: noMethodParts[2]
                                    }
                                };
                            }
                        }
                    }

                    debug('documentWriteCalls offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                })
            };
        }
    },
    "synchronousXHR": {
        "tool": "phantomas",
        "label": "Synchronous Ajax requests",
        "message": "<p>Making an XMLHttpRequest with the <i>async</i> option set to <i>false</i> is deprecated due to the negative effect to performances. The browser's main thread needs to stop everything until the response is received.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 1,
        "hasOffenders": true
    },
    "globalVariables": {
        "tool": "phantomas",
        "label": "Global variables",
        "message": "<p>It is a bad practice because they clutter up the global namespace. If two scripts use the same variable name in the global scope, it can cause conflicts and it is generally hard to debug.</p><p>Global variables also take a (very) little bit longer to be accessed than variables in the local scope of a function.</p>",
        "isOkThreshold": 20,
        "isBadThreshold": 300,
        "isAbnormalThreshold": 800,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offendersHelpers.sortVarsLikeChromeDevTools(offenders)
            };
        }
    },
    "jQueryVersion": {
        "label": "jQuery version",
        "message": "<p>The current latest version of jQuery is 3.5</p><p>Each new version of jQuery optimizes performances. Do not keep an old version of jQuery. Updating can sometimes break a few things, but it is generally quite easy to fix them up. So don't hesitate.</p>",
        "hasOffenders": false,
        "scoreFn": function(data) {
            var differentVersions = data.toolsResults.phantomas.metrics.jQueryVersionsLoaded;

            if (differentVersions === 0 || differentVersions > 1 || !data.toolsResults.phantomas.metrics.jQueryVersion) {
                // Not applicable
                return null;
            } else {
                var value = data.toolsResults.phantomas.metrics.jQueryVersion;
                var score;

                if (value.indexOf('3.3.') === 0 ||
                    value.indexOf('3.4.') === 0 ||
                    value.indexOf('3.5.') === 0 ||
                    value.indexOf('3.6.') === 0 ||
                    value.indexOf('3.7.') === 0 ||
                    value.indexOf('4.0.') === 0) {
                    score = 100;
                } else if (value.indexOf('3.2.') === 0) {
                    score = 90;
                } else if (value.indexOf('3.1.') === 0) {
                    score = 70;
                } else if (value.indexOf('3.0.') === 0) {
                    score = 50;
                } else if (value.indexOf('1.12.') === 0 ||
                           value.indexOf('2.2.') === 0) {
                    score = 40;
                } else if (value.indexOf('1.11.') === 0 ||
                           value.indexOf('2.1.') === 0) {
                    score = 30;
                } else if (value.indexOf('1.10.') === 0 ||
                           value.indexOf('2.0.') === 0) {
                    score = 20;
                } else if (value.indexOf('1.9') === 0) {
                    score = 10;
                } else if (value.indexOf('1.9') === 0 ||
                           value.indexOf('1.8') === 0 ||
                           value.indexOf('1.7') === 0 ||
                           value.indexOf('1.6') === 0 ||
                           value.indexOf('1.5') === 0 ||
                           value.indexOf('1.4') === 0 ||
                           value.indexOf('1.3') === 0 ||
                           value.indexOf('1.2') === 0) {
                    score = 0;
                } else {
                    debug('Unknown jQuery version "%s"', value);
                    return null;
                }

                // Truncate version number (can be long sometimes, no clue why but it can...)
                if (value.length > 30) {
                    value = value.substr(0, 28) + '...';
                }

                return {
                    value: value,
                    score: score,
                    bad: value < 100,
                    abnormal: false,
                    abnormalityScore: 0
                };
            }
        }
    },
    "jQueryVersionsLoaded": {
        "tool": "phantomas",
        "label": "Several jQuery loaded",
        "message": "<p>jQuery is a heavy library. You should <b>never</b> load jQuery more than once on the same page.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 2,
        "isAbnormalThreshold": 3,
        "hasOffenders": true
    },
    "cssParsingErrors": {
        "tool": "phantomas",
        "label": "CSS syntax error",
        "message": "<p>Yellow Lab Tools failed to parse a CSS file. I doubt the problem comes from the css parser.</p><p>Maybe a <a href=\"http://jigsaw.w3.org/css-validator\" target=\"_blank\">CSS validator</a> can help you.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 2,
        "isAbnormalThreshold": 20,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    if (offender === '[inline CSS]') {
                        return {
                            error: 'Empty <style> tag',
                            file: null,
                            line: null,
                            column: null
                        };
                    }

                    if (offender.value) {
                        return {
                            error: offender.value.message || 'Unknown parsing error. The entire file was ignored. As a result, the other CSS metrics and scores are miscalculated.',
                            file: offender.url || null,
                            line: offender.value.position ? offender.value.position.start.line : null,
                            column: offender.value.position ? offender.value.position.start.column : null
                        };
                    } else {
                        return {
                            error: 'Unknown parsing error. The entire file was ignored. As a result, the other CSS metrics and scores are miscalculated.',
                            file: offender,
                            line: null,
                            column: null
                        };
                    }
                })
            };
        }
    },
    "cssRules": {
        "tool": "phantomas",
        "label": "Rules count",
        "message": "<p>Having a huge number of CSS rules hurts performances. If the number of CSS rules is higher than the number of DOM elements, there is clearly a problem.</p><p>Huge stylesheets generally occur when the different pages of a website load all the CSS, concatenated in a single stylesheet, even if a large part of the rules are page-specific. Solution is to create one main CSS file with global rules and one custom file per page.</p>",
        "isOkThreshold": 2000,
        "isBadThreshold": 5000,
        "isAbnormalThreshold": 8000,
        "hasOffenders": true
    },
    "cssComplexSelectors": {
        "tool": "phantomas",
        "label": "Complex selectors",
        "message": "<p>Complex selectors are CSS selectors with 4 or more expressions, like \"#header ul li .foo\".</p><p>They are adding more work for the browser, and this could be avoided by simplifying selectors. The <a href=\"http://getbem.com\" target=\"_blank\">B.E.M. methodology</a> is a useful way to simplify your CSS.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1000,
        "isAbnormalThreshold": 24000,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);
                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssColors": {
        "tool": "phantomas",
        "label": "Colors count",
        "message": "<p>This is the number of different colors defined in CSS.</p><p>Your CSS will be easier to maintain if you keep a small color set.</p>",
        "isOkThreshold": 100,
        "isBadThreshold": 200,
        "isAbnormalThreshold": 500,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders, ruleObject) {
            var deduplicatedObj = {};

            offenders.map(function(offender) {
                var parts = /^([^ ]*) \((\d+) times\)$/.exec(offender.value.message);

                if (!parts) {
                    debug('cssColors offenders transform function error with "%s"', offender.value.message);
                    return;
                }

                var color = parts[1];
                var count = parseInt(parts[2], 10);

                deduplicatedObj[color] = (deduplicatedObj[color] || 0) + count;
            });

            var deduplicatedTable = [];
            for (var color in deduplicatedObj) {
                deduplicatedTable.push({
                    color: color,
                    occurrences: deduplicatedObj[color]
                });
            }

            deduplicatedTable.sort(function(a, b) {
                return b.occurrences - a.occurrences;
            });

            // Override rules.value
            ruleObject.value = deduplicatedTable.length;

            return {
                count: deduplicatedTable.length,
                palette: deduplicatedTable
            };
        }
    },
    "similarColors": {
        "tool": "colorDiff",
        "label": "Similar colors",
        "message": "<p>This is the list of colors found in the stylesheets, that are very close to each other. The eye can barely see the difference.</p><p>Use this list to reduce the number of colors in your palette, it will be easier to maintain.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 60,
        "isAbnormalThreshold": 120,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders
            };
        }
    },
    "cssBreakpoints": {
        "tool": "mediaQueriesChecker",
        "label": "Breakpoints count",
        "message": "<p>This is the number of different breakpoints found in the stylesheets' media queries.</p><p>Please note this rule is based on <i>min-width</i>, <i>max-width</i>, <i>min-device-width</i> and <i>max-device-width</i> media queries only.</p><p>Your CSS will be easier to maintain if you keep a reasonable number of breakpoints. Try to make a fluid design - using percents - to avoid the creation of numerous breakpoints.</p>",
        "isOkThreshold": 10,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 80,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var offendersTable = [];

            for (var offender in offenders) {
                offendersTable.push({
                    breakpoint: offender,
                    count: offenders[offender].count,
                    pixels: offenders[offender].pixels
                });
            }

            return offendersTable;
        }
    },
    "cssMobileFirst": {
        "tool": "mediaQueriesChecker",
        "label": "Not mobile-first media queries",
        "message": "<p>This is the number of CSS rules inside media queries that address small screens.</p><p>The common good practice, when creating a responsive website, is to write it \"mobile-first\". More explanation in <a href=\"http://www.sitepoint.com/introduction-mobile-first-media-queries\" target=\"_blank\">this great article</a>.</p>",
        "isOkThreshold": 60,
        "isBadThreshold": 400,
        "isAbnormalThreshold": 1200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offendersHelpers.orderByFile(offenders);
        }
    },
    "cssImports": {
        "tool": "phantomas",
        "label": "Uses of @import",
        "message": "<p>It’s bad for performance to use @import because CSS files don't get downloaded in parallel.</p><p>You should use &lt;link rel='stylesheet' href='a.css'&gt; instead.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 1,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var splittedOffender = offendersHelpers.cssOffenderPattern(offender);
                    return splittedOffender;
                })
            };
        }
    },
    "cssDuplicatedSelectors": {
        "tool": "phantomas",
        "label": "Duplicated selectors",
        "message": "<p>This is when two or more selectors are strictly identical and should be merged.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 100,
        "isAbnormalThreshold": 200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var parts = /^(.*) \((\d+) times\)$/.exec(offender.value.message);

                if (!parts) {
                    debug('cssDuplicatedSelectors offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    rule: parts[1],
                    occurrences: parseInt(parts[2], 10),
                    file: offender.value.url
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssDuplicatedProperties": {
        "tool": "phantomas",
        "label": "Duplicated properties",
        "message": "<p>This is the number of property definitions duplicated within a selector.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 100,
        "isAbnormalThreshold": 200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^([^{]+) {([^ ]+): (.+)}$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssDuplicatedProperties offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    property: parts[2],
                    rule: parts[1],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssEmptyRules": {
        "tool": "phantomas",
        "label": "Empty rules",
        "message": "<p>Very easy to fix: remove all empty rules.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 120,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(offendersHelpers.cssOffenderPattern);
            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssImportants": {
        "tool": "phantomas",
        "label": "Uses of !important",
        "message": "<p>It can be useful, but only as a last resort. It is a bad practice because it overrides the normal cascading logic. The more you use !important, the more you need it again to over-override. This conducts to a poor maintainability.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 200,
        "isAbnormalThreshold": 1000,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^(.*) {([^ ]+): (.*) ?\!important}$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssImportants offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    rule: parts[1],
                    property: parts[2],
                    value: parts[3],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssOldIEFixes": {
        "tool": "phantomas",
        "label": "Old IE fixes",
        "message": "<p>What browser do you need to support? Once you've got the answer, take a look at these old rules that pollute your CSS code and remove them.</p><p>IE6:<ul><li>* html</li><li>html > body (everything but IE6)</li></ul><p><p>IE7:<ul><li><b>*</b>height: 123px;</li><li>height: 123px <b>!ie</b>;</li></ul><p><p>IE9:<ul><li>-ms-filter</li><li>progid:DXImageTransform.Microsoft</li></ul></p>",
        "isOkThreshold": 0,
        "isBadThreshold": 100,
        "isAbnormalThreshold": 300,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^([^{]*)( {([^ ]+): (.*)})?$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssOldIEFixes offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                var rule = parts[1];
                var property = parts[3];
                var value = parts[4];
                var browser = null;

                if (rule.indexOf('* html') === 0) {
                    rule = rule.replace(/^\* html/, '<b>* html</b>');
                    browser = 'IE6';
                } else if (rule.indexOf('html>body') === 0) {
                    rule = rule.replace(/^html>body/, '<b>html>body</b>');
                    browser = 'IE6';
                } else if (property.indexOf('*') === 0) {
                    property = '<b>' + property + '</b>';
                    browser = 'IE7';
                } else if (value.match(/\!ie$/)) {
                    value = value.replace(/\!ie$/, '<b>!ie</b>');
                    browser = 'IE7';
                } else if (property === '-ms-filter') {
                    property = '<b>-ms-filter</b>';
                    browser = 'IE9';
                } else if (value.indexOf('progid:DXImageTransform.Microsoft') >= 0) {
                    value = value.replace(/progid:DXImageTransform\.Microsoft/, '<b>progid:DXImageTransform.Microsoft</b>');
                    browser = 'IE9';
                }

                var propertyAndValue = (property && value) ? ' {' + property + ': ' + value + '}' : '';
                splittedOffender.bolded = rule + propertyAndValue;
                splittedOffender.browser = browser;

                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssOldPropertyPrefixes": {
        "tool": "phantomas",
        "label": "Old prefixes",
        "message": "<p>Many property prefixes such as -moz- or -webkit- are not needed anymore, or by very few people. Sometimes, they have never even existed. You can remove them or replace them with the non-prefixed version. This will help reducing your stylesheets weight.</p><p>The prefixes database comes from <a href=\"http://caniuse.com/\" target=\"_blank\">Can I Use</a>.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 100,
        "isAbnormalThreshold": 400,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var properties = {};
            offenders.forEach(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^([^{]*)(?: ?{ ?([^ ]+): (.*) ?}) \/\/ (.*)$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssOldPropertyPrefixes offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                var propertyName = parts[2];

                if (!properties[propertyName]) {
                    properties[propertyName] = {
                        property: propertyName,
                        message: parts[4],
                        rules: []
                    };
                }

                properties[propertyName].rules.push({
                    rule: parts[1],
                    value: parts[3],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                });
            });

            // Object to array
            var list = [];
            for (var propertyName in properties) {
                list.push(properties[propertyName]);
            }

            return {
                count: offenders.length,
                list: list
            };
        }
    },
    "cssRedundantBodySelectors": {
        "tool": "phantomas",
        "label": "Redundant body selectors",
        "message": "<p>This is one way to remove complexity from a CSS rule. Generally, when \"body\" is specified in a rule it can be removed, because an element is necessarily inside the body.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 120,
        "isAbnormalThreshold": 400,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);
                splittedOffender.bolded = splittedOffender.css.replace(/body/, '<b>body</b>');
                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssRedundantChildNodesSelectors": {
        "tool": "phantomas",
        "label": "Redundant tags selectors",
        "message": "<p>Some tags included inside other tags are obvious. For example, when \"ul li\" is specified in a rule, \"ul\" can be removed because the \"li\" tag is nearly always inside an \"ul\" container (the \"ol\" container is quite rare). Same thing for \"tr td\", \"select option\", ...</p><p>Lowering compexity in CSS selectors can make the page load a little faster.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 120,
        "isAbnormalThreshold": 400,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var rule = splittedOffender.css || '';
                var redundanters = [
                    ['ul', 'li'],
                    ['ol', 'li'],
                    ['select', 'option'],
                    ['table', 'tr'],
                    ['table', 'th'],
                ];

                redundanters.forEach(function(couple) {
                    rule = rule.replace(new RegExp('(^| |>)' + couple[0] + '([^ >]*)?([ >]| > )' + couple[1] + '([^\\w-]|$)', 'g'), '$1<b>' + couple[0] + '</b>$2$3<b>' + couple[1] + '</b>$4');
                });

                splittedOffender.bolded = rule;

                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "totalWeight": {
        "tool": "redownload",
        "label": "Total weight",
        "message": "<p>The weight is of course very important if you want the page to load fast. Try to stay under 1MB, which is already very long to download over a slow connection.</p>",
        "isOkThreshold": 1572864,
        "isBadThreshold": 3145728,
        "isAbnormalThreshold": 5242880,
        "hasOffenders": true,
        "unit": "bytes"
    },
    "imagesNotOptimized": {
        "tool": "phantomas",
        "label": "Image optimization",
        "message": "<p>This metric measures the number of bytes that could be saved by optimizing images.</p><p>Image optimization is generally one of the easiest way to reduce a page weight, and as a result, the page load time. Don't use Photoshop or other image editing tools, they're not very good for optimization. Use specialized tools such as <a href=\"https://kraken.io/\" target=\"_blank\">Kraken.io</a> or the excellent <a href=\"https://imageoptim.com/\" target=\"_blank\">ImageOptim</a> on Mac. For SVG images, you can use <a href=\"https://jakearchibald.github.io/svgomg/\" target=\"_blank\">SVGOMG</a>.</p><p>The tools in use in YellowLabTools are not set to their maximum optimization power, so you might be able to compress even more!</p>",
        "isOkThreshold": 2048,
        "isBadThreshold": 204800,
        "isAbnormalThreshold": 307200,
        "hasOffenders": true,
        "unit": "bytes",
        "valueTransformFn": function(offenders) {
            let totalGain = 0;
            offenders.forEach((offender) => {
                offender.gain = offender.fileSize - offender.newFileSize;
                totalGain += offender.gain;
            });
            return totalGain;
        },
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "imagesOldFormat": {
        "tool": "phantomas",
        "label": "Old image formats",
        "message": "<p>This metric goes further than \"Image optimization\". Measures the number of bytes that could be saved by converting images to newer and more efficient formats. The best image format is generally AVIF and the second best is WebP.</p><p>Be careful, you need to provide fallback images for old browsers and search engine bots.</p>",
        "isOkThreshold": 2048,
        "isBadThreshold": 512000,
        "isAbnormalThreshold": 819200,
        "hasOffenders": true,
        "unit": "bytes",
        "valueTransformFn": function(offenders) {
            let totalGain = 0;
            offenders.forEach((offender) => {
                offender.gain = offender.fileSize - offender.newFileSize;
                totalGain += offender.gain;
            });
            return totalGain;
        },
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "imagesScaledDown": {
        "tool": "phantomas",
        "label": "Oversized images",
        "message": "<p>This rule compares the number of pixels in a loaded images to the number of physical pixels it is displayed on. Then it estimates the number of KB that could be saved by serving it with the correct dimensions.</p><p>Of course, it is hard to serve perfect images for all screens. For this reason, this rule is quite permissive.</p>",
        "isOkThreshold": 2048,
        "isBadThreshold": 307200,
        "isAbnormalThreshold": 512000,
        "hasOffenders": true,
        "unit": "bytes",
        "valueTransformFn": function(offenders) {
            let totalGain = 0;
            offenders.forEach((offender) => {
                offender.gain = offender.fileSize - offender.newFileSize;
                totalGain += offender.gain;
            });
            return totalGain;
        },
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "imagesExcessiveDensity": {
        "tool": "phantomas",
        "label": "Excessive image density",
        "message": "<p>This metric measures the number of bytes that could be saved by going further than just resizing images.<p>Devices with very high pixel density screen (such as 3x or 4x) are programmed to load high density images. This is the normal behavior, however the human eye barely sees the difference over 2x. This metric alerts you if an image density is > 2.2x.</p><p>There is currently no browser functionnality to prevent the issue (for this reason its impact on global score is low). But you can build your own clever solution!</p>",
        "isOkThreshold": 102400,
        "isBadThreshold": 307200,
        "isAbnormalThreshold": 512000,
        "hasOffenders": true,
        "unit": "bytes",
        "valueTransformFn": function(offenders) {
            let totalGain = 0;
            offenders.forEach((offender) => {
                offender.gain = offender.fileSize - offender.newFileSize;
                totalGain += offender.gain;
            });
            return totalGain;
        },
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "imagesWithIncorrectSizesParam": {
        "tool": "phantomas",
        "label": "Incorrect sizes parameter",
        "message": "<p>When using an adaptative image with a <i>srcset</i> attribute and <i>w</i> values, it is important to correctly set the <i>sizes</i> attribute. Otherwise, the browser might pick the wrong image in the <i>srcset</i>.</p><p>The <a href=\”https://chrome.google.com/webstore/detail/responsive-image-linter/mnddginionlghpblkimpdalcecpnbjln\" target=\"_blank\">Responsive Image Linter</a> extension for Chrome can help you further.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 10,
        "hasOffenders": true
    },
    "compression": {
        "tool": "redownload",
        "label": "Gzip/Brotli compression",
        "message": "<p>Measures the number of bytes that could be saved by compressing textual files. Some files listed below might not be compressed at all, some might be already compressed with Gzip but would become even lighter with Brotli.</p><p>All major server systems are now compatible with Brotli.</p><p>Note that compressing small files (< 1 KB) is arguable, and that some assets such as images should not be compressed as it is already included in their format. <a href=\"https://letstalkaboutwebperf.com/en/gzip-brotli-server-config/\" target=\"_blank\">Here</a> is a list of MIME types that should be compressed.</p>",
        "isOkThreshold": 20480,
        "isBadThreshold": 204800,
        "isAbnormalThreshold": 409600,
        "hasOffenders": true,
        "unit": "bytes"
    },
    "fileMinification": {
        "tool": "redownload",
        "label": "File minification",
        "message": "<p>This is the weight that could be saved if all text resources were correctly minified.</p><p>The tools in use here are <b>UglifyJS</b>, <b>clean-css</b> and <b>HTMLMinifier</b>. These tools are so good that some of your minified files can be marked as unminified. Change your tool if this happens :)</p><p>The gains of minification are generally small, but the impact can be high when these text files are loaded on the critical path.</p>",
        "isOkThreshold": 5125,
        "isBadThreshold": 61440,
        "isAbnormalThreshold": 122880,
        "hasOffenders": true,
        "unit": "bytes"
    },
    "totalRequests": {
        "tool": "redownload",
        "label": "Requests number",
        "message": "<p>Each request slows down the page loading, especially on the protocol HTTP/1, but also a little on HTTP/2 or 3.</p><p>There are several technics to reduce their number:<ul><li>Concatenate JS files</li><li>Concatenate CSS files</li><li>Embed or inline small JS or CSS files in the HTML</li><li>Create sprites</li><li>Base64 encode small images in HTML or stylesheets</li><li>Use lazyloading for images</li></ul></p>",
        "isOkThreshold": 80,
        "isBadThreshold": 240,
        "isAbnormalThreshold": 320,
        "hasOffenders": true
    },
    "domains": {
        "tool": "phantomas",
        "label": "Different domains",
        "message": "<p>For each domain met, the browser needs to make a DNS look-up, which is slow. Avoid having to many different domains and the page should render faster.</p><p>By the way, domain sharding is not a good practice anymore.</p>",
        "isOkThreshold": 12,
        "isBadThreshold": 30,
        "isAbnormalThreshold": 60,
        "hasOffenders": true
    },
    "notFound": {
        "tool": "phantomas",
        "label": "404 not found",
        "message": "<p>404 errors are never cached, so each time a page ask for it, it hits the server. Even if it is behind a CDN or a reverse-proxy cache.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 1,
        "hasOffenders": true
    },
    "closedConnections": {
        "tool": "phantomas",
        "label": "Connections closed",
        "message": "<p>This counts the number of requests not keeping the connection alive (specifying \"Connection: close\" in the response headers). It is only counting a request if it is followed by another request on the same domain.</p><p>This is slowing down the next request, because the brower needs to open a new connection to the server, which means an additional round-trip.</p><p>Correct the problem by setting a Keep-Alive header on the guilty server.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 4,
        "isAbnormalThreshold": 15,
        "hasOffenders": true
    },
    "identicalFiles": {
        "tool": "redownload",
        "label": "Identical content",
        "message": "<p>This is the number of requests that could be avoided, because of downloaded files that have the same content but are loaded from different URLs.</p><p>Try to load them from the same URL.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 15,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "emptyRequests": {
        "tool": "redownload",
        "label": "Empty requests",
        "message": "<p>List of GET requests that respond with an empty body. These are probably the easiest requests to remove.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 5,
        "hasOffenders": true
    },
    "lazyLoadableImagesBelowTheFold": {
        "tool": "phantomas",
        "label": "Below the fold images",
        "message": "<p>This is the number of images displayed below the fold that could be lazy-loaded. This is an excellent way to accelerate the loading time of an heavy page.</p><p>I recommend using <a href=\"https://developer.mozilla.org/docs/Web/API/HTMLImageElement/loading\" target=\"_blank\">loading=&quot;lazy&quot;</a>.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 12,
        "isAbnormalThreshold": 30,
        "hasOffenders": true
    },
    "hiddenImages": {
        "tool": "phantomas",
        "label": "Hidden images",
        "message": "<p>List of all images that have a display:none property, or one of their parents. These images are loaded by the browser even if they're not visible. You might be able to find a way to lazy-load them, only when they get visible.</p><p>As images displayed in 1x1 pixels tend to be trackers, they are excluded from this rule.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 12,
        "isAbnormalThreshold": 30,
        "hasOffenders": true
    },
    "fontsCount": {
        "tool": "redownload",
        "label": "Webfonts number",
        "message": "<p>This is the number of custom web fonts loaded on the page.</p><p>Webfonts are beautiful, but heavy. You should keep their number as low as possible.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 8,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "heavyFonts": {
        "tool": "redownload",
        "label": "Overweighted webfonts",
        "message": "<p>This metric is the sum of all bytes above 40KB in loaded fonts. Over this size, the font is probably not optimized for the web.</p><p>It can be a compresson issue, a font that contains too many glyphs or a font with complex shapes.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 102400,
        "isAbnormalThreshold": 204800,
        "unit": "bytes",
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "unusedUnicodeRanges": {
        "tool": "redownload",
        "label": "Unused Unicode ranges",
        "message": "<p>This metric counts the number of unused Unicode ranges inside each font. For example, one font could include Cyrillic glyphs but none of them are used on the page.</p><p>It also reveals the number of ligatures (letters that are represented differently when close to each other) and hidden chars (glyphs not linked to the unicode system that can't be displayed on the web).</p><p>Because of technical limitations, Yellow Lab Tools checks each font against the glyphs of the entire page. As a result, estimated use is >= to reality. For example, if you read that 10 glyphs are \"possibly used\", it means that these 10 glyphs are used on the page but nothing guaranties that they are displayed using this font.</p><p>Tools such as <a href=\"https://www.fontsquirrel.com/tools/webfont-generator\" target=\"_blank\">Font Squirrel</a> can remove some unicode ranges from a font.</p><p>In the case of an icon font, make sure you only keep the icons that are used on the website and to remove the others. Several tools are able to extract SVG images from a font, then some other tools can generate a font from the SVGs you want to keep.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 8,
        "isAbnormalThreshold": 12,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "nonWoff2Fonts": {
        "tool": "redownload",
        "label": "WOFF 2",
        "message": "<p>The fonts listed here could be lighter if they were served with the latest WOFF 2 font file format. Some online tools can help you easily convert older formats to WOFF 2.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 51200,
        "isAbnormalThreshold": 122880,
        "hasOffenders": true,
        "unit": "bytes"
    },
    "oldHttpProtocol": {
        "label": "HTTP protocols",
        "message": "<p>HTTP/2 is the latest version of the HTTP protocol. It is designed to optimize load speed. HTTP/3 will come soon and should be even faster!</p><p>When a domain sends more than 4 requests over HTTP/1, this metric counts one point for each new request. Below 5 requests, the benefits of HTTP/2 are generally less significant.</p>",
        "hasOffenders": true,
        "scoreFn": function(data) {
            var count = 0;

            var offenders = data.toolsResults.phantomas.offenders.oldHttpProtocol;

            if (offenders) {
                offenders.forEach(function(offender) {
                    if (offender.requests > 4) {
                        count += offender.requests - 4;
                    }
                });    
            }

            var isOkThreshold = 0;
            var isBadThreshold = 25;
            var isAbnormalThreshold = 100;

            var score = (isBadThreshold - count) * 100 / (isBadThreshold - isOkThreshold);
            var abnormalityScore = (isAbnormalThreshold - count) * 100 / (isAbnormalThreshold - isOkThreshold);
            
            
            var result = {
                value: count,
                score: Math.min(Math.max(Math.round(score), 0), 100),
                bad: count > isBadThreshold,
                abnormal: count > isAbnormalThreshold,
                abnormalityScore: Math.min(Math.round(abnormalityScore), 0),
                offendersObj: {
                    count: data.toolsResults.phantomas.metrics.oldHttpProtocol,
                    list: data.toolsResults.phantomas.offenders.oldHttpProtocol || []
                }
            };

            return result;
        }
    },
    "oldTlsProtocol": {
        "tool": "phantomas",
        "label": "TLS protocols",
        "message": "<p>Counts the number of domains that use TLS versions < 1.3. This is the latest version and it includes a faster \"handshake\" technology.</p><p>The 1.0 and 1.1 versions are deprecated because they are unsafe, switch to 1.2 or above as soon as possible.</p><p>The version 1.3 includes an even faster option called 0-RTT, check your server compatibility on <a href='https://www.ssllabs.com/ssltest/' target=\"_blank\">SSL Labs</a>.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 15,
        "hasOffenders": true
    },
    "cachingDisabled": {
        "tool": "phantomas",
        "label": "Caching disabled",
        "message": "<p>Counts responses with caching disabled (max-age=0)</p><p>Fix immediatly if on static assets.</p>",
        "isOkThreshold": 2,
        "isBadThreshold": 15,
        "isAbnormalThreshold": 30,
        "hasOffenders": true
    },
    "cachingNotSpecified": {
        "tool": "phantomas",
        "label": "Caching not specified",
        "message": "<p>When no caching is specified, each browser will handle it differently. Most of the time, it will automatically add a cache for you, but a poor one. You'd better handle it yourself.</p>",
        "isOkThreshold": 5,
        "isBadThreshold": 20,
        "isAbnormalThreshold": 40,
        "hasOffenders": true
    },
    "cachingTooShort": {
        "tool": "phantomas",
        "label": "Caching too short",
        "message": "<p>Responses with too short caching time (less than a week).</p><p>The longer you cache, the better. Add versionning to your static assets, if it's not already done, and set their cache time to one year.</p>",
        "isOkThreshold": 5,
        "isBadThreshold": 25,
        "isAbnormalThreshold": 50,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders
                    .sort(function(a, b) {

                        return a.ttl - b.ttl;

                    }).map(function(obj) {

                        var duration = obj.ttl;
                        var unit = 'seconds';

                        if (duration >= 120) {
                            duration = Math.round(duration / 60);
                            unit = 'minutes';
                        }

                        if (duration >= 120) {
                            duration = Math.round(duration / 60);
                            unit = 'hours';
                        }

                        if (duration >= 48) {
                            duration = Math.round(duration / 24);
                            unit = 'days';
                        }

                        obj.ttlWithUnit = duration;
                        obj.unit = unit;

                        return obj;
                    })
            };
        }
    }
};

module.exports = policies;
